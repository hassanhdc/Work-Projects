import paho.mqtt.client as mqtt_client
import json

client_id = "WKBXXB0054"

# Relevant topics
topic_presence = "bw3/presence"
topic_pong = f"bw3/4/{client_id}/pong"
topic_ping = f"bw3/4/{client_id}/ping"
topic_evm = f"bw3/4/{client_id}/evm3"
topic_iot = f"bw3/4/{client_id}/iot"

# Topics to subscribe to
topics_sub = [topic_ping, topic_evm]

# Online and offline(last-will) message
msg_online = """{"ClientId":"WKBXXB0054","StationId":4,"Status":1}"""
msg_lastwill = """{"ClientId":"WKBXXB0054","StationId":4,"Status":0}"""


def on_connect(client, userdata, flags, rc):
    # Subscribe to relevant topics
    def subscribe_topics(client):
        for topic in topics_sub:
            client.subscribe(topic)
            print(f"Subscribed to topic {topic}")

        # Attach message handlers on subscribed topics
        client.message_callback_add(topic_ping, cb_ping_msg)
        client.message_callback_add(topic_evm, cb_evm_msg)

    # In case of successful connection
    if rc == 0:
        # Publish online status
        client.publish(topic_presence, msg_online)
        print("Connected to MQTT Broker")

        subscribe_topics(client)

    else:
        print("Unable to connect, reason code: ", rc, "\nExiting...")
        exit()


# EVM PING message handler - handle messages received on 'topic_ping'
def cb_ping_msg(client, userdata, msg):
    print(f"\nReceived PING on {msg.topic} : {msg.payload.decode()}")
    print(f"Replying PONG on {topic_pong}")

    client.publish(topic_pong, msg.payload)


# EVM COMMAND message handler - handle messages received on 'topic_evm'
def cb_evm_msg(client, userdata, msg):
    def create_reply(payload):
        # Parse 'msg' payload into JSON and extract 'conversation id'
        parsed_msg = json.loads(payload.decode())
        conversation_id = parsed_msg["ConversationID"]

        # Insert 'conversation id' generated by EVM to create a valid reply
        msg_ack = f"""{{\"ConversationID\":\"{conversation_id}\",\"MessageType\":\"Ack\",\"MessageOrigin\":null,\"From\":\"WKBXXB0054\",\"CommandInvokerGuid\":null,\"To\":\"admin\",\"TimestampOrigin\":1607599458679,\"TimestampHub\":1607599458679,\"Body\":\"{{\\r\\n  \\\"Code\\\": 200,\\r\\n  \\\"Description\\\": \\\"Message Received\\\",\\r\\n  \\\"OriginalMessage\\\": {{\\r\\n    \\\"ConversationID\\\": \\\"13c618d8-c20f-4fc2-a93c-af2fead8ac6a\\\",\\r\\n    \\\"MessageType\\\": \\\"Command\\\",\\r\\n    \\\"MessageOrigin\\\": null,\\r\\n    \\\"From\\\": \\\"admin\\\",\\r\\n    \\\"CommandInvokerGuid\\\": \\\"0841ce8b-f263-435c-b455-f66fd865070e\\\",\\r\\n    \\\"To\\\": \\\"WKBXXB0054\\\",\\r\\n    \\\"TimestampOrigin\\\": 1607599458675,\\r\\n    \\\"TimestampHub\\\": 1607599458675,\\r\\n    \\\"Body\\\": \\\"{{\\\\\\\"CommandType\\\\\\\":\\\\\\\"InCarStatus\\\\\\\",\\\\\\\"CommandID\\\\\\\":10501,\\\\\\\"Params\\\\\\\":{{\\\\\\\"Duration\\\\\\\":60}}\\\",\\r\\n    \\\"Data\\\": null\\r\\n  }}\\r\\n}}\",\"Data\":null}}"""
        msg_success = f"""{{\"ConversationID\":\"{conversation_id}\",\"MessageType\":\"Success\",\"MessageOrigin\":null,\"From\":\"WKBXXB0054\",\"CommandInvokerGuid\":\"7349a511-51e5-4b82-bf36-8900192b788f\",\"To\":\"admin\",\"TimestampOrigin\":1607601281779,\"TimestampHub\":1607601281780,\"Body\":\"{{\\\"success\\\": true,\\\"Result\\\": \\\"{{\\\\\\\"success\\\\\\\":true,\\\\\\\"Data\\\\\\\":{{\\\\\\\"status\\\\\\\":\\\\\\\"StreamingOff\\\\\\\",\\\\\\\"commandInvoker\\\\\\\":\\\\\\\"\\\\\\\"}}}}\\\",\\\"CommandType\\\": \\\"InCarStatus\\\",\\\"CommandID\\\": 10501,\\\"Description\\\": \\\"Operation succeeded.\\\"}}\",\"Data\":null}}"""

        return (msg_ack, msg_success)

    print(f"\nReceived COMMAND on {msg.topic} : {msg.payload.decode()}")

    msg_ack, msg_success = create_reply(msg.payload)

    print(f"Acknowledging on {topic_iot}")
    client.publish(topic_iot, msg_ack)
    client.publish(topic_iot, msg_success)


# Unused - custom disconnect handler - Can be called from an already attached callback
# e.g. 'on_socket_close'
def disconnect_handler(client):
    # Publish offline(last-will) on presence topic
    client.publish(topic_presence, msg_lastwill)

    # disconnect gracefully
    client.disconnect()


def main():

    # EVM host ip - Change as required
    print("Enter host ip address: ", end="")
    host = input()
    print("Enter port: ", end="")
    port = int(input())

    client = mqtt_client.Client(client_id)

    # Attach last will
    client.will_set(topic_presence, msg_lastwill, qos=1, retain=False)

    # Attach connection handler
    client.on_connect = on_connect

    client.connect(host, port)
    client.loop_forever()


try:
    main()
except KeyboardInterrupt:
    print("Exiting...")
